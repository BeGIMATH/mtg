# -*- python -*-
#
#       OpenAlea.mtg
#
#       Copyright 2008 INRIA - CIRAD - INRA  
#
#       File author(s): Christophe Pradal <christophe.pradal.at.cirad.fr>
#
#       Distributed under the Cecill-C License.
#       See accompanying file LICENSE.txt or copy at
#           http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html
# 
#       OpenAlea WebSite : http://openalea.gforge.inria.fr
#
################################################################################

'''
This module provides functions to read / write mtg dtat structure.
'''

from mtg import *
import openalea.plantgl.all as pgl
import re

debug = 0
def log(*args):
    if debug:
        print '  '.join(map(str,args))

def multiscale_edit(s):
    mtg = MTG()

    vid = mtg.root # vid of the support tree, i.e. at the finest scale
    current_vertex = mtg.root
    branching_stack = []

    symbols = ['/', '\\', '[', ']', '+', '<']
    pending_edge = '' # edge type for the next edge to be created
    scale = 0

    for edge_type in symbols:
        s = s.replace(edge_type, '\n%s'%edge_type)
    l = s.split()

    for node in l:
        tag = node[0]
        assert tag in symbols
        
        if tag == '[':
            branching_stack.append(vid)
        elif tag == ']':
            vid = branching_stack.pop()
            current_vertex = vid
        else:
            name = node[1:]
            if tag in ['+', '<']:
                if mtg.scale(vid) == scale:
                    vid = mtg.add_child(vid, edge_type=tag, label=name)
                    current_vertex = vid
                    pending_edge = ''
                else:
                    complex = mtg.complex(current_vertex)
                    current_vertex = mtg.add_component(complex, label=name)
                    pending_edge = tag
            elif tag == '/':
                if mtg.scale(vid) == scale:
                    vid = mtg.add_component(vid, label=name)
                    current_vertex = vid
                    scale += 1
                else:
                    scale += 1
                    component = mtg.add_component(current_vertex, label=name)
                    if mtg.scale(vid) == scale:
                        vid = mtg.add_child(vid, 
                                            child=component, 
                                            edge_type=pending_edge, 
                                            label=name)
                        assert vid == component
                        current_vertex = vid
                    else:
                        current_vertex = component
            elif tag == '\\':
                scale -= 1
                current_vertex = mtg.complex(current_vertex)
    mtg = fat_mtg(mtg)
    return mtg

def read_lsystem_string( string, symbol_at_scale, functional_symbol={}, mtg=None ):
    '''
     Read a string generated by a lsystem.
    
     :Parameters:
      - `string`: The lsystem string representing the axial tree.
      - `symbol_at_scale`: A dict containing the scale for each symbol name.
      _ `functional_symbol`: A dict containing a function for specific symbols.
    
    The args of the function have to be coherent with those in the string.
    The return type of the functions have to be a dictionary of properties: dict(name, value)

    :Retturn: mtg
    '''
    
    s = string
    def get_expr(s, expr):
        res = re.search(expr, s)
        _str = ''
        if res:
            _str = s[res.start():res.end()]
        return _str

    def get_name(s):
        name = r'[a-zA-Z]*'
        return get_expr(s,name)

    def get_args(s):
        args = r'\([0-9,-\.\+]+\)'
        return get_expr(s,args)

    def get_float(s):
        args = r'[0-9-\+]+'
        num = get_expr(s,args)
        return float(num)

    def transform(turtle, mesh):
        x = turtle.getUp()
        z = turtle.getHeading()

        bo = pgl.BaseOrientation(x, z^x)
        matrix = pgl.Transform4(bo.getMatrix())
        matrix.translate(turtle.getPosition())
        mesh = mesh.transform(matrix)
        return mesh
        

    # 1. Create the mtg structure.
    if mtg is None:
        mtg = MTG()

    # 2. add some properties to the MTG
    mtg.add_property('index')
    mtg.add_property('can_label')
    mtg.add_property('geometry')


    vid = mtg.root # vid of the support tree, i.e. at the finest scale
    current_vertex = mtg.root
    branching_stack = []

    pending_edge = '' # edge type for the next edge to be created
    scale = 0

    lsys_symbols = ['[', ']', '/', '+', 'f']
    modules = symbol_at_scale.keys()
    symbols = lsys_symbols + modules

    index = dict(zip(symbol_at_scale.keys(), [0]*len(symbol_at_scale)))

    is_ramif = False 

    # 2. Create a PlantGL Turtle...
    turtle = pgl.Turtle()

    max_scale = max(symbol_at_scale.values())

    for edge_type in symbols:
        if edge_type != 'f':
            s = s.replace(edge_type, '\n%s'%edge_type)
        else:
            s = s.replace('f(', '\nf(')
    l = s.split()

    plant_name = [s for s in symbol_at_scale.keys() if 'plant' in s.lower()][0]

    for node in l:
        # Check if node is a module

        tag = node[0]
        
        if tag == '[':
            branching_stack.append(vid)
            turtle.push()
            is_ramif = True
        elif tag == ']':
            vid = branching_stack.pop()
            current_vertex = vid
            scale = mtg.scale(vid)
            turtle.pop()
            is_ramif = False
        elif tag == '/':
            args = get_args(node[1:])
            if args:
                angle = get_float(args[1:-1])
                turtle.rollR(angle)
            else:
                turtle.rollR()
        elif tag == '+':
            args = get_args(node[1:])
            if args:
                angle = get_float(args[1:-1])
                turtle.left(angle)
            else:
                turtle.left()
        elif tag == 'f' and node[1] == '(':
            args = get_args(node[1:])
            if args:
                length = get_float(args[1:-1])
                if length > 0:
                    turtle.f(length)
            else:
                turtle.f()
        else:
            # add new modules to the mtg (i.e. add nodes)
            name = get_name(node)
            if name not in modules:
                print 'Unknow element %s'% name
                continue
            
            module_scale = symbol_at_scale[name]
            if is_ramif:
                edge_type = '+'
            else:
                edge_type = '<'

            log(node, module_scale, edge_type )
            
            if module_scale == scale:
                if mtg.scale(vid) == scale:
                    vid = mtg.add_child(vid, edge_type=edge_type, label=name)
                    current_vertex = vid
                    pending_edge = ''
                    log('','Cas 1.1', scale, 'mtg.scale(vid)', mtg.scale(vid), 'generated vertex', vid)
                    assert mtg.scale(vid) == module_scale
                else:
                    # add the edge to the current vertex
                    current_vertex = mtg.add_child(current_vertex, edge_type=edge_type, label=name)
                    log('', 'Cas 1.2', scale, 'mtg.scale(vid)', mtg.scale(vid), 'generated vertex', current_vertex)
                    assert mtg.scale(current_vertex) == module_scale
                is_ramif = False
            elif module_scale > scale:
                log('', 'Cas 2', scale, 'mtg.scale(vid)', mtg.scale(vid))

                old_current_vertex = current_vertex
                while module_scale > scale:
                    if mtg.scale(vid) == scale:
                        assert vid == current_vertex
                        vid = mtg.add_component(vid)
                        current_vertex = vid
                        log('', '', 'Cas 2.1', scale, 'generate new component', current_vertex)
                        scale += 1
                        if module_scale == scale:
                            assert mtg.scale(current_vertex) == module_scale
                            mtg.property('label')[current_vertex] = name
                            break
                    else:
                        scale += 1
                        current_vertex = mtg.add_component(current_vertex)
                else:
                    log(node, 'add_child(%d, child=%d)'%(old_current_vertex, current_vertex))
                    mtg.property('label')[current_vertex] = name
                    if mtg.scale(vid) == scale:
                        vid = mtg.add_child(vid, child=current_vertex, edge_type=edge_type)
                        is_ramif = False
            else:
                assert module_scale < scale
                while module_scale < scale:
                    scale -= 1
                    current_vertex = mtg.complex(current_vertex)
                else:
                    current_vertex = mtg.add_child(current_vertex, edge_type=edge_type, label=name)
                    assert mtg.scale(current_vertex) == module_scale
        
            # MANAGE the properties, the geometry and the indices!!!
            index[name] += 1
            if name == plant_name:
                for k in index.keys():
                    if k != name:
                        index[k] = 0

            mtg.property('index')[current_vertex] = index[name]
            if name in functional_symbol:
                features = eval(node, functional_symbol)
                geom = features.get('geometry')
                canlabel = features.get('label')
                if geom:
                    # get the transformation from the turtle
                    geom = transform(turtle, geom)
                    mtg.property('geometry')[current_vertex] = geom

                    if name == 'StemElement':
                        # parse args to know how the turtle has to move .
                        args = get_args(node)[1:-1]
                        list_args= args.split(',')
                        length = float(list_args[1]) # 2nd arg
                        if length > 0:
                            turtle.f(length)

                if canlabel:
                    canlabel.elt_id = index[name]
                    plant_id = mtg.complex_at_scale(current_vertex, scale=1)
                    canlabel.plant_id = mtg.property('index')[plant_id]
                    mtg.property('can_label')[current_vertex] = canlabel
        
    mtg = fat_mtg(mtg)
    return mtg

def axialtree2mtg(tree, scale, scene):
    """
    Create a MTG from an AxialTree with scales.
    :Parameters:
      - `tree`: The axial tree generated by the L-system
      - `scale`: A dict containing the scale for each symbol name.
    
    :Retturn: mtg
    """
    def scene_id(scene):
        d = {}
        for sh in scene:
            d.setdefault(sh.id,[]).append(sh)
        return d

    def change_id(axial_id, mtg_id):
        """
        Change the id of the shape in the scene by the id of the mtg element.
        """

        for shape in geoms[axial_id]:
            shape.id = mtg_id
        mtg.property('geometry')[mtg_id]=geoms[axial_id]

    # The string represented by the axial tree...

    geoms = scene_id(scene)

    mtg = MTG()
    mtg.add_property('geometry')

    vid = mtg.root
    current_vertex = vid
    branching_stack = []

    pending_edge = '' # edge type for the next edge to be created

    max_scale = max(scale.itervalues())
    for aid, label in enumerate(tree):
        label = label.name
        if label == '[':
            branching_stack.append(vid)
            pending_edge = '+'
        elif label == ']':
            vid = branching_stack.pop()
            current_vertex = vid
            pending_edge = ''
        elif label not in scale:
            continue
        else:
            _scale = scale[label]
            if mtg.scale(vid) == mtg.scale(current_vertex) == _scale:
                # Add a vertex at the finer scale
                if pending_edge == '+':
                    edge_type = '+'
                else:
                    edge_type = '<'

                vid = mtg.add_child(vid, edge_type=edge_type, label=label)
                current_vertex = vid
                pending_edge = ''
            elif mtg.scale(vid) < max_scale:
                assert mtg.scale(vid) == mtg.scale(current_vertex)
                # Descend in scale for the first time
                vid = mtg.add_component(vid, label=label)
                current_vertex = vid
            elif mtg.scale(current_vertex) < _scale:
                assert mtg.scale(current_vertex) == _scale - 1
                current_vertex = mtg.add_component(current_vertex, label=label)
                if mtg.scale(vid) == _scale:
                    if pending_edge == '+':
                        edge_type = '+'
                    else:
                        edge_type = '<'
                    vid = mtg.add_child(vid, child=current_vertex, label=label, edge_type=edge_type)
                    assert vid == current_vertex
                    pending_edge = ''
            else:
                while mtg.scale(current_vertex) >= _scale:
                    current_vertex = mtg.complex(current_vertex)
                assert mtg.scale(current_vertex) == _scale - 1
                current_vertex = mtg.add_component(current_vertex, label=label)

            assert mtg.scale(current_vertex) == _scale

            if max_scale == _scale:
                change_id(aid,current_vertex)

    mtg = fat_mtg(mtg)
    return mtg

def mtg2mss(name, mtg, scene, envelop_type = 'CvxHull'):

    from openalea.fractalysis.light import ssFromDict

    l = []
    for scale in range(1, mtg.nb_scales()-1):
        d = {}
        for vid in mtg.vertices(scale=scale):
            d[vid] = list(mtg.components(vid))
        l.append(d)
    print l
    return ssFromDict(name, scene, l, envelop_type)
    

